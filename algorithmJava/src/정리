1. 선수지식
   - 자바문법
   - 배열과 자료구조
   - IO
   - String, StringBuilder, Scanner, StringTokenizer
   - 이중 for
   - 브루트포스(Brute Force)로 우선 답을 구하기
     ---------------------
        완전탐색, 무차별대입...
        가능한 모든 조합이나 경우의 수를 이용해서 무조건 결과를 도출할 수 있도록 하나씩 확인하는 방법
      
2. 배열관련알고리즘
   1) PrefixSum(구간합)
   2) 투포인터알고리즘
      - 문제를 해결하기 위해서 두 개의 인텍스를 관리하고 특정 조건을 만족하는 부분집합이나
        특정값을 찾는 알고리즘
      - 포인터의 위치는 문제를 분석해서 적절하게 정의
        => 구간의 양끝을 가리키도록, 첫 시작값
      - 합이 작으면 오른쪽 포인터를 오른쪽으로 이동해서 합을 키우기
      - 합이 크면 왼쪽 포인터를 오른쪽으로 이동해서 합을 줄이기
      - 필요하면 정렬 후 작업
      미션> 2003번, 1940번  
      
3. 스택
   - 컴퓨터공학에서 가장 기본이 되는 자료구조
   - 한쪽 끝에서만 자료를 넣고 뺄 수 있는 구조
   - Last In First Out(LIFO)
   - 깊이우선탐색에서 스택을 사용
   - 사용자 정의로 스택을 구현해야 한다면 배열을 이용해서 사용자정의 스택을 구현할 수 있다.
   [스택이 적합하다는 것을 판단하는 기준]
   - 가장 최근 데이터와 비교??
   - HTML태그검사, 경로탐색
   숙제
   백준 10799번
   
4. Queue(LinkedList)
   - First In First Out (FIFO)
   - front에서는 삭제연산
   - rear에서는 삽입연산
   - BFS에서 사용
   - 컴퓨터 버퍼, 시작과 끝이 다른 작업
   숙제
   백준 10845번

5. sort
   1) 버블정렬
      - 한 번 반복문이 실행될때 가장 큰 값(내림차순 - 작은 값)이 맨 뒤(맨 앞)으로 이동
      - 전체 n개 데이터가 있으면 최대 n-1본 반복해서 처리하면 완전히 정렬
      - 왼쪽에 있는 숫자와 오른쪽에 있는 숫자를 비교해서 큰수를 뒤로 뺀다.
      
   2) 선택정렬
      - 가장 작은 것(오름차순기준)으=을 선택해서 계속 앞으로 보내기
      - 선택정렬은 정렬되지 않은 영역의 첫 번째 요소부터 마지막 요소까지 비교해서 가장 작은 값을 첫 번째 요소로 가져온다.
   
   3) 삽입정렬
      - 삽입정렬도 버블정렬이나 선택정렬과 마찬가지로 효율성이 떨어진다. - O(n2)
      - 두 가지 영역 즉, 정렬된 영역과 정렬되지 않은 영역으로 나뉜다.
      - 정렬되지 않은 영역에서 요소를 하나씩 꺼내서 정렬된 영역의 적절한 위치에 요소를 삽입하면서 정렬하는 방식
      - 보통 첫 번째 값이 정렬된 값이라고 전제하고 작업
      - 정렬되지 않은 영역의 가장 앞에 있는 요소와 정렬된 영역의 마지막 요소와 비교하기 시작   
        
6. 탐색
   1) 순차탐색
      - 모든 데이터를 순차적으로 하나하나 비교하면서 찾는 데이터가 있는지 확인
      - 리스트가 길면 길수록 오버헤드가 크다.
                      --------
                        어떤 처리를 하기 위해서 들어가는 간접처리시간, 메모리 
      - 효율성을 위해서 보초법을 사용하는데 코드의 간결함을 표현할 수 있다.
      [보초법]
      - 일반적인 순차검색에서 각 요소를 비교할때마다 경계조건을 확인해야한다. 
      - 경계조건은 배열이면 arr.length를 체크해서 벗어나지 않도록 작업
      - 순차검색에서 각요소에 조건을 적용해서 비교하면서 조건을 만족하지 않는 경우에 대한 처리를 하고 있다.
        조건을 만족하지 않는 경우에 대한 연산을 최소화하자
      - 보초법은 우리가 찾으려하는 값을 배열의 마지막 요소에 추가
        => 우리가 찾는 값은 무조건 배열에 존대
        => 마지막요소이면 찾으려고 하는 값이 없다.
        => 마지막 idex라면 배열내에 검색값이 없는 것
        => 따라서 값이 없는 경우 체크를 for문 안에서 하지 않아도 된다.
      - 정렬은 필요없지만 항상 앞에서부터 끝까지 찾아야 하므로 데이터가 많아질수록 느려진다.
          
   2) 이진탐색
      - 정렬되어 있는 데이터에서 특정 데이터를 검색
      - 찾으려고 하는 데이터가 있는 자료구조에서 중앙값을 구하고 찾으려는 값과 비교해서
        데이터의 크기를 절반씩 줄여서 대상을 찾는다.
      - 시작index, 중앙값index, 마지막데이터index 
      - 중앙값과 찾으려는 값을 비교해서 시작index, 중앙값index, 마지막데이터index들을
        변경하면서 범위를 좁혀야 한다.
      - 반복하면서 값을 탐색하다가 중앙값과 찾으려는 값이 같아지면 탐색을 종료
      
      - 반씩 범위를 줄이기 때문에 빠르다.  
      
   3) 깊이우선탐색
      - 탐색을 시작할 노드를 선택
      - 현재 방문한 노드는 방문했다는 것을 기록(배열)
      - 방문하지 않은 인접 노드를 탐색
      - 가능한 깊이 이동
      - 스택을 사용하거나 재귀호출을 사용
      
      [구현내용]
      - 선택한 노드의 행을 순회
      - 아직 방문하지 않은 노드 중에서 연결된 노드 선택해서 탐색
      - 선택된 노드의 행으로 이동해서 탐색, 더 이상 갈곳이 없으면 이전 정점으로 되돌아오기
      - 모든 노드의 탐색이 완료될때까지 반복
      
      1.2606번 문제를 dfs로 풀기
      2.Baek_1260_DFS_BFS의 dfs를 복사해서 dfs_stack메소드를 만들고
        재귀호출이 아니라 스택을 활용해서 작업하도록 변경하기
   
   
   4) 너비우선탐색

7. 재귀
   - 사전적인 의미로 어떤것을 정의할때 자기자신을 참조하는 것을 의미, 즉 자기 자신을 호출하는 함수를 의미
   - 재귀메소드를 정의하는 경우 반드시 종료조건(재귀를 탈출할 수 있는 조건)이 정의되어야 한다.
   
   [재귀메소드를 잘 설계하는 방법]
   1) Base Case
      - 재귀를 멈추고 메소드가 종료되기 위한 조건
      - 적어도 하나 이상의 Base Case가 있어야 한다.
      
   2) Recursive Case
      - 재귀호출이 언제 일어나는지 체크하고 base case에 속할 수 있도록 값을 변경시키거나 상황을 바꿀 수 있어야 한다.
      - 문제를 작게 쪼개기 위해서 사용
        => 문제를 작게 쪼개면 난이도를 낮출 수 있다.
      - 동일한 작업이 반복되어 호출되면 메모리에 보관(자바에서는 메모리에 보관하는 방법 - 배열, HashMap사용)
        ---------------------------------
                Memoization
            

8. 그래프
	1) 용어
	   -노드(정점), 간선(엣지)
	   -무방향그래프, 방향그래프
	   -정점의 차수(degree) :정점에 연결된 엣지의 수를 의미
	   -무함뱡그래프: 정점의 차수와 잔선의 수가 같음
	   -방향그래프: 진입차수와 진출차수의 갯수로 나뉜다.
	            ------  -----------
	              들어오는 방향      |_나가는 방향
   


